//package throttler
//
//import (
//	"sync"
//	"time"
//)
//
//type cacheItem struct {
//	count      int64
//	expiration int64
//}
//
//func (c *cacheItem) Expired() bool {
//	return time.Now().UnixNano() > c.expiration
//}
//
//type cache struct {
//	items           map[string]*cacheItem
//	duration        time.Duration
//	mu              sync.RWMutex
//	cleanupInterval time.Duration
//}
//
//func (c *cache) Get(key string) (int64, bool) {
//	item, found := c.getItem(key)
//
//	if !found {
//		return 0, found
//	}
//
//	return item.count, found
//}
//
//func (c *cache) getItem(key string) (*cacheItem, bool) {
//	c.mu.Lock()
//	defer c.mu.Unlock()
//	item := c.items[key]
//
//	if item != nil {
//		return item, true
//	}
//
//	return item, false
//}
//
//func (c *cache) setItem(key string, item *cacheItem) {
//	c.mu.Lock()
//	defer c.mu.Unlock()
//	c.items[key] = item
//}
//
//func (c *cache) Increment(key string) (result bool) {
//	countOld, found := c.getItem(key)
//	result = found
//	count := &cacheItem{
//		count:      0,
//		expiration: time.Now().Add(c.duration).UnixNano(),
//	}
//
//	if found && !countOld.Expired() {
//		count.count = 1 + countOld.count
//		count.expiration = countOld.expiration
//	}
//
//	c.setItem(key, count)
//
//	return result
//}
//
//func (c *cache) cleanup() {
//	c.mu.Lock()
//	defer c.mu.Unlock()
//
//	for k := range c.items {
//		if c.items[k].Expired() {
//			delete(c.items, k)
//		}
//	}
//}
//
//func (c *cache) startJanitor() {
//	interval := time.NewTicker(c.cleanupInterval)
//
//	for {
//		select {
//		case <-interval.C:
//			c.cleanup()
//		}
//	}
//}
//
//type MemoryCacheOpts struct {
//	DefaultTTL             *time.Duration
//	DefaultCleanupInterval *time.Duration
//}
//
//func NewMemoryCache(opts *MemoryCacheOpts) ICacheProvider {
//	defaultTtl := time.Minute
//	if opts.DefaultTTL != nil {
//		defaultTtl = *opts.DefaultTTL
//	}
//
//	defaultCleanupInterval := time.Minute
//	if opts.DefaultCleanupInterval != nil {
//		defaultCleanupInterval = *opts.DefaultCleanupInterval
//	}
//
//	c := &cache{
//		duration:        defaultTtl,
//		cleanupInterval: defaultCleanupInterval,
//		items:           map[string]*cacheItem{},
//		mu:              sync.RWMutex{},
//	}
//
//	go c.startJanitor()
//
//	return c
//}
//
//type ICacheProvider interface {
//	Get(string) (int64, bool)
//	Increment(string) bool
//}
